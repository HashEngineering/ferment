# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod types { pub mod nested { # [doc = "FFI-representation of the ProtocolError"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ProtocolError { IdentifierError (* mut std :: os :: raw :: c_char ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: ProtocolError > for ProtocolError { unsafe fn ffi_from_const (ffi : * const ProtocolError) -> crate :: nested :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { ProtocolError :: IdentifierError (o_o_0 ,) => crate :: nested :: ProtocolError :: IdentifierError (ferment_interfaces :: FFIConversion :: ffi_from (* o_o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: ProtocolError) -> * const ProtocolError { ferment_interfaces :: boxed (match obj { crate :: nested :: ProtocolError :: IdentifierError (o_o_0 ,) => ProtocolError :: IdentifierError (ferment_interfaces :: FFIConversion :: ffi_to (o_o_0) ,) , }) } unsafe fn destroy (ffi : * mut ProtocolError) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ProtocolError { fn drop (& mut self) { unsafe { match self { ProtocolError :: IdentifierError (o_o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (* o_o_0) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ProtocolError_IdentifierError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut ProtocolError { ferment_interfaces :: boxed (ProtocolError :: IdentifierError (o_o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ProtocolError_destroy (ffi : * mut ProtocolError) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: FromProofImpl\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct FromProofImpl { pub obj : * mut std :: os :: raw :: c_char , } impl ferment_interfaces :: FFIConversion < crate :: nested :: FromProofImpl > for FromProofImpl { unsafe fn ffi_from_const (ffi : * const FromProofImpl) -> crate :: nested :: FromProofImpl { let ffi_ref = & * ffi ; crate :: nested :: FromProofImpl { obj : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . obj) , } } unsafe fn ffi_to_const (obj : crate :: nested :: FromProofImpl) -> * const FromProofImpl { ferment_interfaces :: boxed (FromProofImpl { obj : ferment_interfaces :: FFIConversion :: ffi_to (obj . obj) , }) } unsafe fn destroy (ffi : * mut FromProofImpl) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for FromProofImpl { fn drop (& mut self) { unsafe { let ffi_ref = self ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (ffi_ref . obj) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn FromProofImpl_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut FromProofImpl { ferment_interfaces :: boxed (FromProofImpl { obj , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn FromProofImpl_destroy (ffi : * mut FromProofImpl) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the IdentityResponse"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum IdentityResponse { Get (* mut std :: os :: raw :: c_char ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentityResponse > for IdentityResponse { unsafe fn ffi_from_const (ffi : * const IdentityResponse) -> crate :: nested :: IdentityResponse { let ffi_ref = & * ffi ; match ffi_ref { IdentityResponse :: Get (o_o_0 ,) => crate :: nested :: IdentityResponse :: Get (ferment_interfaces :: FFIConversion :: ffi_from (* o_o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: IdentityResponse) -> * const IdentityResponse { ferment_interfaces :: boxed (match obj { crate :: nested :: IdentityResponse :: Get (o_o_0 ,) => IdentityResponse :: Get (ferment_interfaces :: FFIConversion :: ffi_to (o_o_0) ,) , }) } unsafe fn destroy (ffi : * mut IdentityResponse) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityResponse { fn drop (& mut self) { unsafe { match self { IdentityResponse :: Get (o_o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (* o_o_0) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityResponse_Get_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut IdentityResponse { ferment_interfaces :: boxed (IdentityResponse :: Get (o_o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityResponse_destroy (ffi : * mut IdentityResponse) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the IdentityRequest"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum IdentityRequest { Get (* mut std :: os :: raw :: c_char ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentityRequest > for IdentityRequest { unsafe fn ffi_from_const (ffi : * const IdentityRequest) -> crate :: nested :: IdentityRequest { let ffi_ref = & * ffi ; match ffi_ref { IdentityRequest :: Get (o_o_0 ,) => crate :: nested :: IdentityRequest :: Get (ferment_interfaces :: FFIConversion :: ffi_from (* o_o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: IdentityRequest) -> * const IdentityRequest { ferment_interfaces :: boxed (match obj { crate :: nested :: IdentityRequest :: Get (o_o_0 ,) => IdentityRequest :: Get (ferment_interfaces :: FFIConversion :: ffi_to (o_o_0) ,) , }) } unsafe fn destroy (ffi : * mut IdentityRequest) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityRequest { fn drop (& mut self) { unsafe { match self { IdentityRequest :: Get (o_o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (* o_o_0) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityRequest_Get_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut IdentityRequest { ferment_interfaces :: boxed (IdentityRequest :: Get (o_o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityRequest_destroy (ffi : * mut IdentityRequest) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod from_proof { pub mod from_proof { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct FromProof_VTable { pub ffi_maybe_from_proof : unsafe extern "C" fn (request : * mut I , response : * mut O , platform_version : u32 ,) -> * mut crate :: fermented :: generics :: Result_ok_Option_Self_err_ProtocolError , pub ffi_from_proof : unsafe extern "C" fn (request : * mut I , response : * mut O , platform_version : u32 ,) -> * mut crate :: fermented :: generics :: Result_ok_Self_err_ProtocolError , } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct FromProof { pub object : * const () , pub vtable : * const FromProof_VTable } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod generics { }