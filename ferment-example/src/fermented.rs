# [allow (clippy :: let_and_return , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod types { pub mod chain { pub mod common { pub mod chain_type { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IHaveChainSettings_VTable { pub name : unsafe extern "C" fn (obj : * const () ,) -> * mut std :: os :: raw :: c_char , pub genesis_hash : unsafe extern "C" fn (obj : * const () ,) -> * mut crate :: fermented :: types :: nested :: HashID , pub genesis_height : unsafe extern "C" fn (obj : * const () ,) -> u32 , pub has_genesis_hash : unsafe extern "C" fn (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> bool , pub get_hash_by_hash : unsafe extern "C" fn (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> * mut crate :: fermented :: types :: nested :: HashID , pub should_process_llmq_of_type : unsafe extern "C" fn (obj : * const () , llmq_type : u16 ,) -> bool , pub find_masternode_list : unsafe extern "C" fn (obj : * const () , cached_mn_lists : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , unknown_mn_lists : * mut crate :: fermented :: generics :: Vec_crate_nested_HashID ,) -> * mut crate :: fermented :: generics :: Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError , } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IHaveChainSettings_TraitObject { pub object : * const () , pub vtable : * const IHaveChainSettings_VTable } # [doc = "FFI-representation of the DevnetType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum DevnetType { JackDaniels = 0 , Devnet333 = 1 , Chacha = 2 , Mojito = 3 , WhiteRussian = 4 , } impl ferment_interfaces :: FFIConversion < crate :: chain :: common :: chain_type :: DevnetType > for DevnetType { unsafe fn ffi_from_const (ffi : * const DevnetType) -> crate :: chain :: common :: chain_type :: DevnetType { let ffi_ref = & * ffi ; match ffi_ref { DevnetType :: JackDaniels => crate :: chain :: common :: chain_type :: DevnetType :: JackDaniels , DevnetType :: Devnet333 => crate :: chain :: common :: chain_type :: DevnetType :: Devnet333 , DevnetType :: Chacha => crate :: chain :: common :: chain_type :: DevnetType :: Chacha , DevnetType :: Mojito => crate :: chain :: common :: chain_type :: DevnetType :: Mojito , DevnetType :: WhiteRussian => crate :: chain :: common :: chain_type :: DevnetType :: WhiteRussian , } } unsafe fn ffi_to_const (obj : crate :: chain :: common :: chain_type :: DevnetType) -> * const DevnetType { ferment_interfaces :: boxed (match obj { crate :: chain :: common :: chain_type :: DevnetType :: JackDaniels => DevnetType :: JackDaniels , crate :: chain :: common :: chain_type :: DevnetType :: Devnet333 => DevnetType :: Devnet333 , crate :: chain :: common :: chain_type :: DevnetType :: Chacha => DevnetType :: Chacha , crate :: chain :: common :: chain_type :: DevnetType :: Mojito => DevnetType :: Mojito , crate :: chain :: common :: chain_type :: DevnetType :: WhiteRussian => DevnetType :: WhiteRussian , }) } unsafe fn destroy (ffi : * mut DevnetType) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for DevnetType { fn drop (& mut self) { unsafe { match self { DevnetType :: JackDaniels => { } , DevnetType :: Devnet333 => { } , DevnetType :: Chacha => { } , DevnetType :: Mojito => { } , DevnetType :: WhiteRussian => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DevnetType_destroy (ffi : * mut DevnetType) { ferment_interfaces :: unbox_any (ffi) ; } # [allow (non_snake_case , non_upper_case_globals)] static DevnetType_IHaveChainSettings_VTable : IHaveChainSettings_VTable = { unsafe extern "C" fn DevnetType_name (obj : * const () ,) -> * mut std :: os :: raw :: c_char { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: name (cast_obj ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_genesis_hash (obj : * const () ,) -> * mut crate :: fermented :: types :: nested :: HashID { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: genesis_hash (cast_obj ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_genesis_height (obj : * const () ,) -> u32 { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: genesis_height (cast_obj ,) ; obj } unsafe extern "C" fn DevnetType_has_genesis_hash (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> bool { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: has_genesis_hash (cast_obj , ferment_interfaces :: FFIConversion :: ffi_from (hash) ,) ; obj } unsafe extern "C" fn DevnetType_get_hash_by_hash (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> * mut crate :: fermented :: types :: nested :: HashID { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: get_hash_by_hash (cast_obj , ferment_interfaces :: FFIConversion :: ffi_from (hash) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_should_process_llmq_of_type (obj : * const () , llmq_type : u16 ,) -> bool { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: should_process_llmq_of_type (cast_obj , llmq_type ,) ; obj } unsafe extern "C" fn DevnetType_find_masternode_list (obj : * const () , cached_mn_lists : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , unknown_mn_lists : * mut crate :: fermented :: generics :: Vec_crate_nested_HashID ,) -> * mut crate :: fermented :: generics :: Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: DevnetType)) ; let obj = < crate :: chain :: common :: chain_type :: DevnetType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: find_masternode_list (cast_obj , & ferment_interfaces :: FFIConversion :: ffi_from (cached_mn_lists) , & mut ferment_interfaces :: FFIConversion :: ffi_from (unknown_mn_lists) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } IHaveChainSettings_VTable { name : DevnetType_name , genesis_hash : DevnetType_genesis_hash , genesis_height : DevnetType_genesis_height , has_genesis_hash : DevnetType_has_genesis_hash , get_hash_by_hash : DevnetType_get_hash_by_hash , should_process_llmq_of_type : DevnetType_should_process_llmq_of_type , find_masternode_list : DevnetType_find_masternode_list , } } ; # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub extern "C" fn DevnetType_as_IHaveChainSettings_TraitObject (obj : * const crate :: chain :: common :: chain_type :: DevnetType) -> IHaveChainSettings_TraitObject { IHaveChainSettings_TraitObject { object : obj as * const () , vtable : & DevnetType_IHaveChainSettings_VTable , } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DevnetType_as_IHaveChainSettings_TraitObject_destroy (obj : IHaveChainSettings_TraitObject) { ferment_interfaces :: unbox_any (obj . object as * mut crate :: chain :: common :: chain_type :: DevnetType) ; } # [doc = "FFI-representation of the get_chain_settings"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_chain_settings () -> * mut crate :: fermented :: types :: chain :: common :: chain_type :: ChainType { let obj = crate :: chain :: common :: chain_type :: get_chain_settings () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [doc = "FFI-representation of the ChainType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ChainType { MainNet , TestNet , DevNet (* mut crate :: fermented :: types :: chain :: common :: chain_type :: DevnetType ,) , } impl ferment_interfaces :: FFIConversion < crate :: chain :: common :: chain_type :: ChainType > for ChainType { unsafe fn ffi_from_const (ffi : * const ChainType) -> crate :: chain :: common :: chain_type :: ChainType { let ffi_ref = & * ffi ; match ffi_ref { ChainType :: MainNet => crate :: chain :: common :: chain_type :: ChainType :: MainNet , ChainType :: TestNet => crate :: chain :: common :: chain_type :: ChainType :: TestNet , ChainType :: DevNet (o_0 ,) => crate :: chain :: common :: chain_type :: ChainType :: DevNet (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: chain :: common :: chain_type :: ChainType) -> * const ChainType { ferment_interfaces :: boxed (match obj { crate :: chain :: common :: chain_type :: ChainType :: MainNet => ChainType :: MainNet , crate :: chain :: common :: chain_type :: ChainType :: TestNet => ChainType :: TestNet , crate :: chain :: common :: chain_type :: ChainType :: DevNet (o_0 ,) => ChainType :: DevNet (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut ChainType) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ChainType { fn drop (& mut self) { unsafe { match self { ChainType :: MainNet => { } , ChainType :: TestNet => { } , ChainType :: DevNet (o_0 ,) => { < crate :: fermented :: types :: chain :: common :: chain_type :: DevnetType as ferment_interfaces :: FFIConversion < crate :: chain :: common :: chain_type :: DevnetType >> :: destroy (o_0 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ChainType_destroy (ffi : * mut ChainType) { ferment_interfaces :: unbox_any (ffi) ; } # [allow (non_snake_case , non_upper_case_globals)] static ChainType_IHaveChainSettings_VTable : IHaveChainSettings_VTable = { unsafe extern "C" fn ChainType_name (obj : * const () ,) -> * mut std :: os :: raw :: c_char { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: name (cast_obj ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_genesis_hash (obj : * const () ,) -> * mut crate :: fermented :: types :: nested :: HashID { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: genesis_hash (cast_obj ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_genesis_height (obj : * const () ,) -> u32 { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: genesis_height (cast_obj ,) ; obj } unsafe extern "C" fn ChainType_has_genesis_hash (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> bool { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: has_genesis_hash (cast_obj , ferment_interfaces :: FFIConversion :: ffi_from (hash) ,) ; obj } unsafe extern "C" fn ChainType_get_hash_by_hash (obj : * const () , hash : * mut crate :: fermented :: types :: nested :: HashID ,) -> * mut crate :: fermented :: types :: nested :: HashID { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: get_hash_by_hash (cast_obj , ferment_interfaces :: FFIConversion :: ffi_from (hash) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_should_process_llmq_of_type (obj : * const () , llmq_type : u16 ,) -> bool { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: should_process_llmq_of_type (cast_obj , llmq_type ,) ; obj } unsafe extern "C" fn ChainType_find_masternode_list (obj : * const () , cached_mn_lists : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , unknown_mn_lists : * mut crate :: fermented :: generics :: Vec_crate_nested_HashID ,) -> * mut crate :: fermented :: generics :: Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { let cast_obj = & (* (obj as * const crate :: chain :: common :: chain_type :: ChainType)) ; let obj = < crate :: chain :: common :: chain_type :: ChainType as crate :: chain :: common :: chain_type :: IHaveChainSettings > :: find_masternode_list (cast_obj , & ferment_interfaces :: FFIConversion :: ffi_from (cached_mn_lists) , & mut ferment_interfaces :: FFIConversion :: ffi_from (unknown_mn_lists) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } IHaveChainSettings_VTable { name : ChainType_name , genesis_hash : ChainType_genesis_hash , genesis_height : ChainType_genesis_height , has_genesis_hash : ChainType_has_genesis_hash , get_hash_by_hash : ChainType_get_hash_by_hash , should_process_llmq_of_type : ChainType_should_process_llmq_of_type , find_masternode_list : ChainType_find_masternode_list , } } ; # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub extern "C" fn ChainType_as_IHaveChainSettings_TraitObject (obj : * const crate :: chain :: common :: chain_type :: ChainType) -> IHaveChainSettings_TraitObject { IHaveChainSettings_TraitObject { object : obj as * const () , vtable : & ChainType_IHaveChainSettings_VTable , } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ChainType_as_IHaveChainSettings_TraitObject_destroy (obj : IHaveChainSettings_TraitObject) { ferment_interfaces :: unbox_any (obj . object as * mut crate :: chain :: common :: chain_type :: ChainType) ; } } } } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: RootStruct\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct RootStruct { pub name : * mut std :: os :: raw :: c_char , } impl ferment_interfaces :: FFIConversion < crate :: RootStruct > for RootStruct { unsafe fn ffi_from_const (ffi : * const RootStruct) -> crate :: RootStruct { let ffi_ref = & * ffi ; crate :: RootStruct { name : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . name) , } } unsafe fn ffi_to_const (obj : crate :: RootStruct) -> * const RootStruct { ferment_interfaces :: boxed (RootStruct { name : ferment_interfaces :: FFIConversion :: ffi_to (obj . name) , }) } unsafe fn destroy (ffi : * mut RootStruct) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for RootStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (ffi_ref . name) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn RootStruct_ctor (name : * mut std :: os :: raw :: c_char) -> * mut RootStruct { ferment_interfaces :: boxed (RootStruct { name , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn RootStruct_destroy (ffi : * mut RootStruct) { ferment_interfaces :: unbox_any (ffi) ; } pub mod example { pub mod address { # [doc = "FFI-representation of the get_chain_hashes_by_map"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_chain_hashes_by_map (map : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID ,) -> * mut std :: os :: raw :: c_char { let obj = crate :: example :: address :: get_chain_hashes_by_map (ferment_interfaces :: FFIConversion :: ffi_from (map) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [doc = "FFI-representation of the get_chain_type_string"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_chain_type_string (chain_type : * mut crate :: fermented :: types :: chain :: common :: chain_type :: ChainType ,) -> * mut std :: os :: raw :: c_char { let obj = crate :: example :: address :: get_chain_type_string (ferment_interfaces :: FFIConversion :: ffi_from (chain_type) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [doc = "FFI-representation of the address_with_script_pubkey"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_address_with_script_pubkey (script : * mut crate :: fermented :: generics :: Vec_u8 ,) -> * mut std :: os :: raw :: c_char { let obj = crate :: example :: address :: address_with_script_pubkey (ferment_interfaces :: FFIConversion :: ffi_from (script) ,) ; ferment_interfaces :: FFIConversion :: ffi_to_opt (obj) } } } pub mod nested { # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: MapOfHashes\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MapOfHashes (* mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: MapOfHashes > for MapOfHashes { unsafe fn ffi_from_const (ffi : * const MapOfHashes) -> crate :: nested :: MapOfHashes { let ffi_ref = & * ffi ; ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) } unsafe fn ffi_to_const (obj : crate :: nested :: MapOfHashes) -> * const MapOfHashes { ferment_interfaces :: boxed (MapOfHashes (ferment_interfaces :: FFIConversion :: ffi_to (obj))) } unsafe fn destroy (ffi : * mut MapOfHashes) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MapOfHashes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MapOfHashes_ctor (o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) -> * mut MapOfHashes { ferment_interfaces :: boxed (MapOfHashes (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MapOfHashes_destroy (ffi : * mut MapOfHashes) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: TimestampMillis\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TimestampMillis (u64 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: TimestampMillis > for TimestampMillis { unsafe fn ffi_from_const (ffi : * const TimestampMillis) -> crate :: nested :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: nested :: TimestampMillis) -> * const TimestampMillis { ferment_interfaces :: boxed (TimestampMillis (obj)) } unsafe fn destroy (ffi : * mut TimestampMillis) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TimestampMillis_ctor (o_0 : u64) -> * mut TimestampMillis { ferment_interfaces :: boxed (TimestampMillis (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TimestampMillis_destroy (ffi : * mut TimestampMillis) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the KeyType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum KeyType { ECDSA_SECP256K1 = 0 , BLS12_381 = 1 , ECDSA_HASH160 = 2 , BIP13_SCRIPT_HASH = 3 , EDDSA_25519_HASH160 = 4 , } impl ferment_interfaces :: FFIConversion < crate :: nested :: KeyType > for KeyType { unsafe fn ffi_from_const (ffi : * const KeyType) -> crate :: nested :: KeyType { let ffi_ref = & * ffi ; match ffi_ref { KeyType :: ECDSA_SECP256K1 => crate :: nested :: KeyType :: ECDSA_SECP256K1 , KeyType :: BLS12_381 => crate :: nested :: KeyType :: BLS12_381 , KeyType :: ECDSA_HASH160 => crate :: nested :: KeyType :: ECDSA_HASH160 , KeyType :: BIP13_SCRIPT_HASH => crate :: nested :: KeyType :: BIP13_SCRIPT_HASH , KeyType :: EDDSA_25519_HASH160 => crate :: nested :: KeyType :: EDDSA_25519_HASH160 , } } unsafe fn ffi_to_const (obj : crate :: nested :: KeyType) -> * const KeyType { ferment_interfaces :: boxed (match obj { crate :: nested :: KeyType :: ECDSA_SECP256K1 => KeyType :: ECDSA_SECP256K1 , crate :: nested :: KeyType :: BLS12_381 => KeyType :: BLS12_381 , crate :: nested :: KeyType :: ECDSA_HASH160 => KeyType :: ECDSA_HASH160 , crate :: nested :: KeyType :: BIP13_SCRIPT_HASH => KeyType :: BIP13_SCRIPT_HASH , crate :: nested :: KeyType :: EDDSA_25519_HASH160 => KeyType :: EDDSA_25519_HASH160 , }) } unsafe fn destroy (ffi : * mut KeyType) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for KeyType { fn drop (& mut self) { unsafe { match self { KeyType :: ECDSA_SECP256K1 => { } , KeyType :: BLS12_381 => { } , KeyType :: ECDSA_HASH160 => { } , KeyType :: BIP13_SCRIPT_HASH => { } , KeyType :: EDDSA_25519_HASH160 => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn KeyType_destroy (ffi : * mut KeyType) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: MyIdentityFactory\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MyIdentityFactory { pub first : u32 , } impl ferment_interfaces :: FFIConversion < crate :: nested :: MyIdentityFactory > for MyIdentityFactory { unsafe fn ffi_from_const (ffi : * const MyIdentityFactory) -> crate :: nested :: MyIdentityFactory { let ffi_ref = & * ffi ; crate :: nested :: MyIdentityFactory { first : ffi_ref . first , } } unsafe fn ffi_to_const (obj : crate :: nested :: MyIdentityFactory) -> * const MyIdentityFactory { ferment_interfaces :: boxed (MyIdentityFactory { first : obj . first , }) } unsafe fn destroy (ffi : * mut MyIdentityFactory) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MyIdentityFactory { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MyIdentityFactory_ctor (first : u32) -> * mut MyIdentityFactory { ferment_interfaces :: boxed (MyIdentityFactory { first , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MyIdentityFactory_destroy (ffi : * mut MyIdentityFactory) { ferment_interfaces :: unbox_any (ffi) ; } # [allow (non_snake_case , non_upper_case_globals)] static MyIdentityFactory_IdentityFactory_VTable : IdentityFactory_VTable = { unsafe extern "C" fn MyIdentityFactory_get_identity (obj : * const () , identifier : * mut crate :: fermented :: types :: nested :: Identifier ,) -> * mut crate :: fermented :: types :: nested :: Identity { let cast_obj = & (* (obj as * const crate :: nested :: MyIdentityFactory)) ; let obj = < crate :: nested :: MyIdentityFactory as crate :: nested :: IdentityFactory > :: get_identity (cast_obj , ferment_interfaces :: FFIConversion :: ffi_from (identifier) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } IdentityFactory_VTable { get_identity : MyIdentityFactory_get_identity , } } ; # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub extern "C" fn MyIdentityFactory_as_IdentityFactory_TraitObject (obj : * const crate :: nested :: MyIdentityFactory) -> IdentityFactory_TraitObject { IdentityFactory_TraitObject { object : obj as * const () , vtable : & MyIdentityFactory_IdentityFactory_VTable , } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MyIdentityFactory_as_IdentityFactory_TraitObject_destroy (obj : IdentityFactory_TraitObject) { ferment_interfaces :: unbox_any (obj . object as * mut crate :: nested :: MyIdentityFactory) ; } # [doc = "FFI-representation of the ShouldProcessDiffWithRangeCallback"] # [allow (non_camel_case_types)] pub type ShouldProcessDiffWithRangeCallback = unsafe extern "C" fn (base_block_hash : * mut crate :: fermented :: types :: nested :: HashID , block_hash : * mut crate :: fermented :: types :: nested :: HashID , context : * mut ferment_interfaces :: fermented :: types :: OpaqueContext_FFI) -> * mut crate :: fermented :: types :: nested :: ProtocolError ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: SimpleData\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct SimpleData (* mut crate :: fermented :: generics :: Vec_u32 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: SimpleData > for SimpleData { unsafe fn ffi_from_const (ffi : * const SimpleData) -> crate :: nested :: SimpleData { let ffi_ref = & * ffi ; crate :: nested :: SimpleData (ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) ,) } unsafe fn ffi_to_const (obj : crate :: nested :: SimpleData) -> * const SimpleData { ferment_interfaces :: boxed (SimpleData (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut SimpleData) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for SimpleData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn SimpleData_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_u32) -> * mut SimpleData { ferment_interfaces :: boxed (SimpleData (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn SimpleData_destroy (ffi : * mut SimpleData) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: IdentityPublicKeyV0\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityPublicKeyV0 { pub id : * mut crate :: fermented :: types :: nested :: KeyID , pub purpose : * mut crate :: fermented :: types :: nested :: Purpose , pub security_level : * mut crate :: fermented :: types :: nested :: SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: nested :: ContractBounds , pub key_type : * mut crate :: fermented :: types :: nested :: KeyType , pub read_only : bool , pub data : * mut crate :: fermented :: types :: nested :: BinaryData , pub disabled_at : * mut crate :: fermented :: types :: nested :: TimestampMillis , } impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentityPublicKeyV0 > for IdentityPublicKeyV0 { unsafe fn ffi_from_const (ffi : * const IdentityPublicKeyV0) -> crate :: nested :: IdentityPublicKeyV0 { let ffi_ref = & * ffi ; crate :: nested :: IdentityPublicKeyV0 { id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . id) , purpose : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . purpose) , security_level : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . security_level) , contract_bounds : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . contract_bounds) , key_type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . key_type) , read_only : ffi_ref . read_only , data : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . data) , disabled_at : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . disabled_at) , } } unsafe fn ffi_to_const (obj : crate :: nested :: IdentityPublicKeyV0) -> * const IdentityPublicKeyV0 { ferment_interfaces :: boxed (IdentityPublicKeyV0 { id : ferment_interfaces :: FFIConversion :: ffi_to (obj . id) , purpose : ferment_interfaces :: FFIConversion :: ffi_to (obj . purpose) , security_level : ferment_interfaces :: FFIConversion :: ffi_to (obj . security_level) , contract_bounds : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . contract_bounds) , key_type : ferment_interfaces :: FFIConversion :: ffi_to (obj . key_type) , read_only : obj . read_only , data : ferment_interfaces :: FFIConversion :: ffi_to (obj . data) , disabled_at : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . disabled_at) , }) } unsafe fn destroy (ffi : * mut IdentityPublicKeyV0) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityPublicKeyV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; < crate :: fermented :: types :: nested :: KeyID as ferment_interfaces :: FFIConversion < crate :: nested :: KeyID >> :: destroy (ffi_ref . id) ; < crate :: fermented :: types :: nested :: Purpose as ferment_interfaces :: FFIConversion < crate :: nested :: Purpose >> :: destroy (ffi_ref . purpose) ; < crate :: fermented :: types :: nested :: SecurityLevel as ferment_interfaces :: FFIConversion < crate :: nested :: SecurityLevel >> :: destroy (ffi_ref . security_level) ; if ! ffi_ref . contract_bounds . is_null () { ferment_interfaces :: unbox_any (ffi_ref . contract_bounds) ; } ; < crate :: fermented :: types :: nested :: KeyType as ferment_interfaces :: FFIConversion < crate :: nested :: KeyType >> :: destroy (ffi_ref . key_type) ; { } ; < crate :: fermented :: types :: nested :: BinaryData as ferment_interfaces :: FFIConversion < crate :: nested :: BinaryData >> :: destroy (ffi_ref . data) ; if ! ffi_ref . disabled_at . is_null () { ferment_interfaces :: unbox_any (ffi_ref . disabled_at) ; } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityPublicKeyV0_ctor (id : * mut crate :: fermented :: types :: nested :: KeyID , purpose : * mut crate :: fermented :: types :: nested :: Purpose , security_level : * mut crate :: fermented :: types :: nested :: SecurityLevel , contract_bounds : * mut crate :: fermented :: types :: nested :: ContractBounds , key_type : * mut crate :: fermented :: types :: nested :: KeyType , read_only : bool , data : * mut crate :: fermented :: types :: nested :: BinaryData , disabled_at : * mut crate :: fermented :: types :: nested :: TimestampMillis) -> * mut IdentityPublicKeyV0 { ferment_interfaces :: boxed (IdentityPublicKeyV0 { id , purpose , security_level , contract_bounds , key_type , read_only , data , disabled_at , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityPublicKeyV0_destroy (ffi : * mut IdentityPublicKeyV0) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the Purpose"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum Purpose { AUTHENTICATION = 0 , ENCRYPTION = 1 , DECRYPTION = 2 , WITHDRAW = 3 , SYSTEM = 4 , VOTING = 5 , } impl ferment_interfaces :: FFIConversion < crate :: nested :: Purpose > for Purpose { unsafe fn ffi_from_const (ffi : * const Purpose) -> crate :: nested :: Purpose { let ffi_ref = & * ffi ; match ffi_ref { Purpose :: AUTHENTICATION => crate :: nested :: Purpose :: AUTHENTICATION , Purpose :: ENCRYPTION => crate :: nested :: Purpose :: ENCRYPTION , Purpose :: DECRYPTION => crate :: nested :: Purpose :: DECRYPTION , Purpose :: WITHDRAW => crate :: nested :: Purpose :: WITHDRAW , Purpose :: SYSTEM => crate :: nested :: Purpose :: SYSTEM , Purpose :: VOTING => crate :: nested :: Purpose :: VOTING , } } unsafe fn ffi_to_const (obj : crate :: nested :: Purpose) -> * const Purpose { ferment_interfaces :: boxed (match obj { crate :: nested :: Purpose :: AUTHENTICATION => Purpose :: AUTHENTICATION , crate :: nested :: Purpose :: ENCRYPTION => Purpose :: ENCRYPTION , crate :: nested :: Purpose :: DECRYPTION => Purpose :: DECRYPTION , crate :: nested :: Purpose :: WITHDRAW => Purpose :: WITHDRAW , crate :: nested :: Purpose :: SYSTEM => Purpose :: SYSTEM , crate :: nested :: Purpose :: VOTING => Purpose :: VOTING , }) } unsafe fn destroy (ffi : * mut Purpose) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Purpose { fn drop (& mut self) { unsafe { match self { Purpose :: AUTHENTICATION => { } , Purpose :: ENCRYPTION => { } , Purpose :: DECRYPTION => { } , Purpose :: WITHDRAW => { } , Purpose :: SYSTEM => { } , Purpose :: VOTING => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Purpose_destroy (ffi : * mut Purpose) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the find_hash_by_u32"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_find_hash_by_u32 (key : u32 , map : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_crate_nested_HashID ,) -> * mut crate :: fermented :: types :: nested :: HashID { let obj = crate :: nested :: find_hash_by_u32 (key , ferment_interfaces :: FFIConversion :: ffi_from (map) ,) ; ferment_interfaces :: FFIConversion :: ffi_to_opt (obj) } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: MapOfVecHashes\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MapOfVecHashes (* mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: MapOfVecHashes > for MapOfVecHashes { unsafe fn ffi_from_const (ffi : * const MapOfVecHashes) -> crate :: nested :: MapOfVecHashes { let ffi_ref = & * ffi ; ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) } unsafe fn ffi_to_const (obj : crate :: nested :: MapOfVecHashes) -> * const MapOfVecHashes { ferment_interfaces :: boxed (MapOfVecHashes (ferment_interfaces :: FFIConversion :: ffi_to (obj))) } unsafe fn destroy (ffi : * mut MapOfVecHashes) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MapOfVecHashes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MapOfVecHashes_ctor (o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID) -> * mut MapOfVecHashes { ferment_interfaces :: boxed (MapOfVecHashes (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MapOfVecHashes_destroy (ffi : * mut MapOfVecHashes) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: UsedStruct\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct UsedStruct (* mut crate :: fermented :: types :: nested :: HashID ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: UsedStruct > for UsedStruct { unsafe fn ffi_from_const (ffi : * const UsedStruct) -> crate :: nested :: UsedStruct { let ffi_ref = & * ffi ; ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) } unsafe fn ffi_to_const (obj : crate :: nested :: UsedStruct) -> * const UsedStruct { ferment_interfaces :: boxed (UsedStruct (ferment_interfaces :: FFIConversion :: ffi_to (obj))) } unsafe fn destroy (ffi : * mut UsedStruct) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for UsedStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; < crate :: fermented :: types :: nested :: HashID as ferment_interfaces :: FFIConversion < crate :: nested :: HashID >> :: destroy (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UsedStruct_ctor (o_0 : * mut crate :: fermented :: types :: nested :: HashID) -> * mut UsedStruct { ferment_interfaces :: boxed (UsedStruct (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UsedStruct_destroy (ffi : * mut UsedStruct) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the AddInsightCallback"] # [allow (non_camel_case_types)] pub type AddInsightCallback = unsafe extern "C" fn (block_hash : * mut crate :: fermented :: types :: nested :: HashID , context : * mut ferment_interfaces :: fermented :: types :: OpaqueContext_FFI) ; # [doc = "FFI-representation of the get_an_identity"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_an_identity () -> * mut crate :: fermented :: types :: nested :: Identity { let obj = crate :: nested :: get_an_identity () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityFactory_VTable { pub get_identity : unsafe extern "C" fn (obj : * const () , identifier : * mut crate :: fermented :: types :: nested :: Identifier ,) -> * mut crate :: fermented :: types :: nested :: Identity , } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityFactory_TraitObject { pub object : * const () , pub vtable : * const IdentityFactory_VTable } # [doc = "FFI-representation of the Identity"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum Identity { V0 (* mut crate :: fermented :: types :: nested :: IdentityV0 ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: Identity > for Identity { unsafe fn ffi_from_const (ffi : * const Identity) -> crate :: nested :: Identity { let ffi_ref = & * ffi ; match ffi_ref { Identity :: V0 (o_0 ,) => crate :: nested :: Identity :: V0 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: Identity) -> * const Identity { ferment_interfaces :: boxed (match obj { crate :: nested :: Identity :: V0 (o_0 ,) => Identity :: V0 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut Identity) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Identity { fn drop (& mut self) { unsafe { match self { Identity :: V0 (o_0 ,) => { < crate :: fermented :: types :: nested :: IdentityV0 as ferment_interfaces :: FFIConversion < crate :: nested :: IdentityV0 >> :: destroy (o_0 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identity_destroy (ffi : * mut Identity) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: IdentifierBytes32\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentifierBytes32 (* mut [u8 ; 32] ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentifierBytes32 > for IdentifierBytes32 { unsafe fn ffi_from_const (ffi : * const IdentifierBytes32) -> crate :: nested :: IdentifierBytes32 { let ffi_ref = & * ffi ; crate :: nested :: IdentifierBytes32 (* ffi_ref . 0 ,) } unsafe fn ffi_to_const (obj : crate :: nested :: IdentifierBytes32) -> * const IdentifierBytes32 { ferment_interfaces :: boxed (IdentifierBytes32 (ferment_interfaces :: boxed (obj . 0) ,)) } unsafe fn destroy (ffi : * mut IdentifierBytes32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentifierBytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentifierBytes32_ctor (o_0 : * mut [u8 ; 32]) -> * mut IdentifierBytes32 { ferment_interfaces :: boxed (IdentifierBytes32 (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentifierBytes32_destroy (ffi : * mut IdentifierBytes32) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: HashID\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct HashID (* mut [u8 ; 32] ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: HashID > for HashID { unsafe fn ffi_from_const (ffi : * const HashID) -> crate :: nested :: HashID { let ffi_ref = & * ffi ; * ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: nested :: HashID) -> * const HashID { ferment_interfaces :: boxed (HashID (ferment_interfaces :: boxed (obj))) } unsafe fn destroy (ffi : * mut HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for HashID { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn HashID_ctor (o_0 : * mut [u8 ; 32]) -> * mut HashID { ferment_interfaces :: boxed (HashID (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn HashID_destroy (ffi : * mut HashID) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the get_identity_factory"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_identity_factory () -> * mut crate :: fermented :: types :: nested :: MyIdentityFactory { let obj = crate :: nested :: get_identity_factory () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [doc = "FFI-representation of the IdentityPublicKey"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum IdentityPublicKey { V0 (* mut crate :: fermented :: types :: nested :: IdentityPublicKeyV0 ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentityPublicKey > for IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const IdentityPublicKey) -> crate :: nested :: IdentityPublicKey { let ffi_ref = & * ffi ; match ffi_ref { IdentityPublicKey :: V0 (o_0 ,) => crate :: nested :: IdentityPublicKey :: V0 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: IdentityPublicKey) -> * const IdentityPublicKey { ferment_interfaces :: boxed (match obj { crate :: nested :: IdentityPublicKey :: V0 (o_0 ,) => IdentityPublicKey :: V0 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut IdentityPublicKey) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityPublicKey { fn drop (& mut self) { unsafe { match self { IdentityPublicKey :: V0 (o_0 ,) => { < crate :: fermented :: types :: nested :: IdentityPublicKeyV0 as ferment_interfaces :: FFIConversion < crate :: nested :: IdentityPublicKeyV0 >> :: destroy (o_0 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityPublicKey_destroy (ffi : * mut IdentityPublicKey) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: KeyID\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct KeyID (u32 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: KeyID > for KeyID { unsafe fn ffi_from_const (ffi : * const KeyID) -> crate :: nested :: KeyID { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: nested :: KeyID) -> * const KeyID { ferment_interfaces :: boxed (KeyID (obj)) } unsafe fn destroy (ffi : * mut KeyID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for KeyID { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn KeyID_ctor (o_0 : u32) -> * mut KeyID { ferment_interfaces :: boxed (KeyID (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn KeyID_destroy (ffi : * mut KeyID) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: IdentityV0\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IdentityV0 { pub id : * mut crate :: fermented :: types :: nested :: Identifier , pub public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey , pub balance : u64 , pub revision : * mut crate :: fermented :: types :: nested :: Revision , } impl ferment_interfaces :: FFIConversion < crate :: nested :: IdentityV0 > for IdentityV0 { unsafe fn ffi_from_const (ffi : * const IdentityV0) -> crate :: nested :: IdentityV0 { let ffi_ref = & * ffi ; crate :: nested :: IdentityV0 { id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . revision) , } } unsafe fn ffi_to_const (obj : crate :: nested :: IdentityV0) -> * const IdentityV0 { ferment_interfaces :: boxed (IdentityV0 { id : ferment_interfaces :: FFIConversion :: ffi_to (obj . id) , public_keys : ferment_interfaces :: FFIConversion :: ffi_to (obj . public_keys) , balance : obj . balance , revision : ferment_interfaces :: FFIConversion :: ffi_to (obj . revision) , }) } unsafe fn destroy (ffi : * mut IdentityV0) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for IdentityV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; < crate :: fermented :: types :: nested :: Identifier as ferment_interfaces :: FFIConversion < crate :: nested :: Identifier >> :: destroy (ffi_ref . id) ; ferment_interfaces :: unbox_any (ffi_ref . public_keys) ; ; { } ; < crate :: fermented :: types :: nested :: Revision as ferment_interfaces :: FFIConversion < crate :: nested :: Revision >> :: destroy (ffi_ref . revision) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityV0_ctor (id : * mut crate :: fermented :: types :: nested :: Identifier , public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey , balance : u64 , revision : * mut crate :: fermented :: types :: nested :: Revision) -> * mut IdentityV0 { ferment_interfaces :: boxed (IdentityV0 { id , public_keys , balance , revision , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn IdentityV0_destroy (ffi : * mut IdentityV0) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the TestEnum"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum TestEnum { Variant1 (* mut std :: os :: raw :: c_char ,) , Variant2 , Variant3 (* mut crate :: fermented :: types :: nested :: HashID , u32 ,) , Variant4 (* mut crate :: fermented :: types :: nested :: HashID , u32 , * mut std :: os :: raw :: c_char ,) , Variant5 (* mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_crate_nested_HashID , u32 , * mut std :: os :: raw :: c_char ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: TestEnum > for TestEnum { unsafe fn ffi_from_const (ffi : * const TestEnum) -> crate :: nested :: TestEnum { let ffi_ref = & * ffi ; match ffi_ref { TestEnum :: Variant1 (o_0 ,) => crate :: nested :: TestEnum :: Variant1 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , TestEnum :: Variant2 => crate :: nested :: TestEnum :: Variant2 , TestEnum :: Variant3 (o_0 , o_1 ,) => crate :: nested :: TestEnum :: Variant3 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) , * o_1 ,) , TestEnum :: Variant4 (o_0 , o_1 , o_2 ,) => crate :: nested :: TestEnum :: Variant4 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) , * o_1 , ferment_interfaces :: FFIConversion :: ffi_from (* o_2) ,) , TestEnum :: Variant5 (o_0 , o_1 , o_2 ,) => crate :: nested :: TestEnum :: Variant5 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) , * o_1 , ferment_interfaces :: FFIConversion :: ffi_from (* o_2) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: TestEnum) -> * const TestEnum { ferment_interfaces :: boxed (match obj { crate :: nested :: TestEnum :: Variant1 (o_0 ,) => TestEnum :: Variant1 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: TestEnum :: Variant2 => TestEnum :: Variant2 , crate :: nested :: TestEnum :: Variant3 (o_0 , o_1 ,) => TestEnum :: Variant3 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) , o_1 ,) , crate :: nested :: TestEnum :: Variant4 (o_0 , o_1 , o_2 ,) => TestEnum :: Variant4 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) , o_1 , ferment_interfaces :: FFIConversion :: ffi_to (o_2) ,) , crate :: nested :: TestEnum :: Variant5 (o_0 , o_1 , o_2 ,) => TestEnum :: Variant5 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) , o_1 , ferment_interfaces :: FFIConversion :: ffi_to (o_2) ,) , }) } unsafe fn destroy (ffi : * mut TestEnum) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TestEnum { fn drop (& mut self) { unsafe { match self { TestEnum :: Variant1 (o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_0 . to_owned ()) ; } , TestEnum :: Variant2 => { } , TestEnum :: Variant3 (o_0 , o_1 ,) => { < crate :: fermented :: types :: nested :: HashID as ferment_interfaces :: FFIConversion < crate :: nested :: HashID >> :: destroy (o_0 . to_owned ()) ; { } ; } , TestEnum :: Variant4 (o_0 , o_1 , o_2 ,) => { < crate :: fermented :: types :: nested :: HashID as ferment_interfaces :: FFIConversion < crate :: nested :: HashID >> :: destroy (o_0 . to_owned ()) ; { } ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_2 . to_owned ()) ; } , TestEnum :: Variant5 (o_0 , o_1 , o_2 ,) => { ferment_interfaces :: unbox_any (o_0 . to_owned ()) ; ; { } ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_2 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TestEnum_destroy (ffi : * mut TestEnum) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the ProtocolError"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ProtocolError { IdentifierError (* mut std :: os :: raw :: c_char ,) , StringDecodeError (* mut std :: os :: raw :: c_char ,) , StringDecodeError2 (* mut std :: os :: raw :: c_char , u32 ,) , EmptyPublicKeyDataError , MaxEncodedBytesReachedError { max_size_kbytes : usize , size_hit : usize , } , EncodingError (* mut std :: os :: raw :: c_char ,) , EncodingError2 (* mut std :: os :: raw :: c_char ,) , UnknownVersionMismatch , } impl ferment_interfaces :: FFIConversion < crate :: nested :: ProtocolError > for ProtocolError { unsafe fn ffi_from_const (ffi : * const ProtocolError) -> crate :: nested :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { ProtocolError :: IdentifierError (o_0 ,) => crate :: nested :: ProtocolError :: IdentifierError (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , ProtocolError :: StringDecodeError (o_0 ,) => crate :: nested :: ProtocolError :: StringDecodeError (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , ProtocolError :: StringDecodeError2 (o_0 , o_1 ,) => crate :: nested :: ProtocolError :: StringDecodeError2 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) , * o_1 ,) , ProtocolError :: EmptyPublicKeyDataError => crate :: nested :: ProtocolError :: EmptyPublicKeyDataError , ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit , } => crate :: nested :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : * max_size_kbytes , size_hit : * size_hit , } , ProtocolError :: EncodingError (o_0 ,) => crate :: nested :: ProtocolError :: EncodingError (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , ProtocolError :: EncodingError2 (o_0 ,) => crate :: nested :: ProtocolError :: EncodingError2 (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , ProtocolError :: UnknownVersionMismatch => crate :: nested :: ProtocolError :: UnknownVersionMismatch , } } unsafe fn ffi_to_const (obj : crate :: nested :: ProtocolError) -> * const ProtocolError { ferment_interfaces :: boxed (match obj { crate :: nested :: ProtocolError :: IdentifierError (o_0 ,) => ProtocolError :: IdentifierError (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: ProtocolError :: StringDecodeError (o_0 ,) => ProtocolError :: StringDecodeError (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: ProtocolError :: StringDecodeError2 (o_0 , o_1 ,) => ProtocolError :: StringDecodeError2 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) , o_1 ,) , crate :: nested :: ProtocolError :: EmptyPublicKeyDataError => ProtocolError :: EmptyPublicKeyDataError , crate :: nested :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit , } => ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : max_size_kbytes , size_hit : size_hit , } , crate :: nested :: ProtocolError :: EncodingError (o_0 ,) => ProtocolError :: EncodingError (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: ProtocolError :: EncodingError2 (o_0 ,) => ProtocolError :: EncodingError2 (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: ProtocolError :: UnknownVersionMismatch => ProtocolError :: UnknownVersionMismatch , }) } unsafe fn destroy (ffi : * mut ProtocolError) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ProtocolError { fn drop (& mut self) { unsafe { match self { ProtocolError :: IdentifierError (o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_0 . to_owned ()) ; } , ProtocolError :: StringDecodeError (o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_0 . to_owned ()) ; } , ProtocolError :: StringDecodeError2 (o_0 , o_1 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_0 . to_owned ()) ; { } ; } , ProtocolError :: EmptyPublicKeyDataError => { } , ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit , } => { { } { } } , ProtocolError :: EncodingError (o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_0 . to_owned ()) ; } , ProtocolError :: EncodingError2 (o_0 ,) => { < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < & str >> :: destroy (o_0 . to_owned ()) ; } , ProtocolError :: UnknownVersionMismatch => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ProtocolError_destroy (ffi : * mut ProtocolError) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: Identifier\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Identifier (* mut crate :: fermented :: types :: nested :: IdentifierBytes32 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: Identifier > for Identifier { unsafe fn ffi_from_const (ffi : * const Identifier) -> crate :: nested :: Identifier { let ffi_ref = & * ffi ; crate :: nested :: Identifier (ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) ,) } unsafe fn ffi_to_const (obj : crate :: nested :: Identifier) -> * const Identifier { ferment_interfaces :: boxed (Identifier (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut Identifier) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Identifier { fn drop (& mut self) { unsafe { let ffi_ref = self ; < crate :: fermented :: types :: nested :: IdentifierBytes32 as ferment_interfaces :: FFIConversion < crate :: nested :: IdentifierBytes32 >> :: destroy (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identifier_ctor (o_0 : * mut crate :: fermented :: types :: nested :: IdentifierBytes32) -> * mut Identifier { ferment_interfaces :: boxed (Identifier (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Identifier_destroy (ffi : * mut Identifier) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: TestStruct\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TestStruct { pub vec_u8 : * mut crate :: fermented :: generics :: Vec_u8 , pub vec_u32 : * mut crate :: fermented :: generics :: Vec_u32 , pub vec_vec_u32 : * mut crate :: fermented :: generics :: Vec_Vec_u32 , pub map_key_simple_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , pub map_key_simple_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_crate_nested_HashID , pub map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 , pub map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , pub map_key_simple_value_map_key_simple_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 , pub map_key_simple_value_map_key_simple_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID , pub map_key_simple_value_map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 , pub map_key_simple_value_map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , pub map_key_complex_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_u32 , pub map_key_complex_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , pub map_key_complex_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 , pub map_key_complex_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID , pub map_key_complex_value_map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 , pub map_key_complex_value_map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , pub map_key_complex_value_map_key_simple_value_map_key_complex_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < crate :: nested :: TestStruct > for TestStruct { unsafe fn ffi_from_const (ffi : * const TestStruct) -> crate :: nested :: TestStruct { let ffi_ref = & * ffi ; crate :: nested :: TestStruct { vec_u8 : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . vec_u8) , vec_u32 : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . vec_u32) , vec_vec_u32 : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . vec_vec_u32) , map_key_simple_value_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_simple) , map_key_simple_value_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_complex) , map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_vec_simple) , map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_vec_complex) , map_key_simple_value_map_key_simple_value_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_map_key_simple_value_simple) , map_key_simple_value_map_key_simple_value_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_map_key_simple_value_complex) , map_key_simple_value_map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_map_key_simple_value_vec_simple) , map_key_simple_value_map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_simple_value_map_key_simple_value_vec_complex) , map_key_complex_value_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_simple) , map_key_complex_value_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_complex) , map_key_complex_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_vec_simple) , map_key_complex_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_vec_complex) , map_key_complex_value_map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_map_key_simple_value_vec_simple) , map_key_complex_value_map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_map_key_simple_value_vec_complex) , map_key_complex_value_map_key_simple_value_map_key_complex_value_complex : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . map_key_complex_value_map_key_simple_value_map_key_complex_value_complex) , } } unsafe fn ffi_to_const (obj : crate :: nested :: TestStruct) -> * const TestStruct { ferment_interfaces :: boxed (TestStruct { vec_u8 : ferment_interfaces :: FFIConversion :: ffi_to (obj . vec_u8) , vec_u32 : ferment_interfaces :: FFIConversion :: ffi_to (obj . vec_u32) , vec_vec_u32 : ferment_interfaces :: FFIConversion :: ffi_to (obj . vec_vec_u32) , map_key_simple_value_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_simple) , map_key_simple_value_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_complex) , map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_vec_simple) , map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_vec_complex) , map_key_simple_value_map_key_simple_value_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_map_key_simple_value_simple) , map_key_simple_value_map_key_simple_value_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_map_key_simple_value_complex) , map_key_simple_value_map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_map_key_simple_value_vec_simple) , map_key_simple_value_map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_simple_value_map_key_simple_value_vec_complex) , map_key_complex_value_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_simple) , map_key_complex_value_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_complex) , map_key_complex_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_vec_simple) , map_key_complex_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_vec_complex) , map_key_complex_value_map_key_simple_value_vec_simple : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_map_key_simple_value_vec_simple) , map_key_complex_value_map_key_simple_value_vec_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_map_key_simple_value_vec_complex) , map_key_complex_value_map_key_simple_value_map_key_complex_value_complex : ferment_interfaces :: FFIConversion :: ffi_to (obj . map_key_complex_value_map_key_simple_value_map_key_complex_value_complex) , }) } unsafe fn destroy (ffi : * mut TestStruct) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TestStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . vec_u8) ; ; ferment_interfaces :: unbox_any (ffi_ref . vec_u32) ; ; ferment_interfaces :: unbox_any (ffi_ref . vec_vec_u32) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_vec_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_vec_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_map_key_simple_value_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_map_key_simple_value_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_map_key_simple_value_vec_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_simple_value_map_key_simple_value_vec_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_vec_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_vec_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_map_key_simple_value_vec_simple) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_map_key_simple_value_vec_complex) ; ; ferment_interfaces :: unbox_any (ffi_ref . map_key_complex_value_map_key_simple_value_map_key_complex_value_complex) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TestStruct_ctor (vec_u8 : * mut crate :: fermented :: generics :: Vec_u8 , vec_u32 : * mut crate :: fermented :: generics :: Vec_u32 , vec_vec_u32 : * mut crate :: fermented :: generics :: Vec_Vec_u32 , map_key_simple_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , map_key_simple_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_crate_nested_HashID , map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 , map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , map_key_simple_value_map_key_simple_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 , map_key_simple_value_map_key_simple_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID , map_key_simple_value_map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 , map_key_simple_value_map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , map_key_complex_value_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_u32 , map_key_complex_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , map_key_complex_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 , map_key_complex_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID , map_key_complex_value_map_key_simple_value_vec_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 , map_key_complex_value_map_key_simple_value_vec_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , map_key_complex_value_map_key_simple_value_map_key_complex_value_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) -> * mut TestStruct { ferment_interfaces :: boxed (TestStruct { vec_u8 , vec_u32 , vec_vec_u32 , map_key_simple_value_simple , map_key_simple_value_complex , map_key_simple_value_vec_simple , map_key_simple_value_vec_complex , map_key_simple_value_map_key_simple_value_simple , map_key_simple_value_map_key_simple_value_complex , map_key_simple_value_map_key_simple_value_vec_simple , map_key_simple_value_map_key_simple_value_vec_complex , map_key_complex_value_simple , map_key_complex_value_complex , map_key_complex_value_vec_simple , map_key_complex_value_vec_complex , map_key_complex_value_map_key_simple_value_vec_simple , map_key_complex_value_map_key_simple_value_vec_complex , map_key_complex_value_map_key_simple_value_map_key_complex_value_complex , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TestStruct_destroy (ffi : * mut TestStruct) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the ContractBounds"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ContractBounds { SingleContract (* mut crate :: fermented :: types :: nested :: Identifier ,) , SingleContractDocumentType (* mut crate :: fermented :: types :: nested :: Identifier , * mut std :: os :: raw :: c_char ,) , } impl ferment_interfaces :: FFIConversion < crate :: nested :: ContractBounds > for ContractBounds { unsafe fn ffi_from_const (ffi : * const ContractBounds) -> crate :: nested :: ContractBounds { let ffi_ref = & * ffi ; match ffi_ref { ContractBounds :: SingleContract (o_0 ,) => crate :: nested :: ContractBounds :: SingleContract (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , ContractBounds :: SingleContractDocumentType (o_0 , o_1 ,) => crate :: nested :: ContractBounds :: SingleContractDocumentType (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) , ferment_interfaces :: FFIConversion :: ffi_from (* o_1) ,) , } } unsafe fn ffi_to_const (obj : crate :: nested :: ContractBounds) -> * const ContractBounds { ferment_interfaces :: boxed (match obj { crate :: nested :: ContractBounds :: SingleContract (o_0 ,) => ContractBounds :: SingleContract (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , crate :: nested :: ContractBounds :: SingleContractDocumentType (o_0 , o_1 ,) => ContractBounds :: SingleContractDocumentType (ferment_interfaces :: FFIConversion :: ffi_to (o_0) , ferment_interfaces :: FFIConversion :: ffi_to (o_1) ,) , }) } unsafe fn destroy (ffi : * mut ContractBounds) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ContractBounds { fn drop (& mut self) { unsafe { match self { ContractBounds :: SingleContract (o_0 ,) => { < crate :: fermented :: types :: nested :: Identifier as ferment_interfaces :: FFIConversion < crate :: nested :: Identifier >> :: destroy (o_0 . to_owned ()) ; } , ContractBounds :: SingleContractDocumentType (o_0 , o_1 ,) => { < crate :: fermented :: types :: nested :: Identifier as ferment_interfaces :: FFIConversion < crate :: nested :: Identifier >> :: destroy (o_0 . to_owned ()) ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < String >> :: destroy (o_1 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ContractBounds_destroy (ffi : * mut ContractBounds) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: DataContractNotPresentError\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct DataContractNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: nested :: Identifier , } impl ferment_interfaces :: FFIConversion < crate :: nested :: DataContractNotPresentError > for DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const DataContractNotPresentError) -> crate :: nested :: DataContractNotPresentError { let ffi_ref = & * ffi ; crate :: nested :: DataContractNotPresentError { data_contract_id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . data_contract_id) , } } unsafe fn ffi_to_const (obj : crate :: nested :: DataContractNotPresentError) -> * const DataContractNotPresentError { ferment_interfaces :: boxed (DataContractNotPresentError { data_contract_id : ferment_interfaces :: FFIConversion :: ffi_to (obj . data_contract_id) , }) } unsafe fn destroy (ffi : * mut DataContractNotPresentError) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; < crate :: fermented :: types :: nested :: Identifier as ferment_interfaces :: FFIConversion < crate :: nested :: Identifier >> :: destroy (ffi_ref . data_contract_id) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DataContractNotPresentError_ctor (data_contract_id : * mut crate :: fermented :: types :: nested :: Identifier) -> * mut DataContractNotPresentError { ferment_interfaces :: boxed (DataContractNotPresentError { data_contract_id , }) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DataContractNotPresentError_destroy (ffi : * mut DataContractNotPresentError) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: UnnamedPair\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct UnnamedPair (* mut [u8 ; 32] , u32 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: UnnamedPair > for UnnamedPair { unsafe fn ffi_from_const (ffi : * const UnnamedPair) -> crate :: nested :: UnnamedPair { let ffi_ref = & * ffi ; crate :: nested :: UnnamedPair (* ffi_ref . 0 , ffi_ref . 1 ,) } unsafe fn ffi_to_const (obj : crate :: nested :: UnnamedPair) -> * const UnnamedPair { ferment_interfaces :: boxed (UnnamedPair (ferment_interfaces :: boxed (obj . 0) , obj . 1 ,)) } unsafe fn destroy (ffi : * mut UnnamedPair) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for UnnamedPair { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UnnamedPair_ctor (o_0 : * mut [u8 ; 32] , o_1 : u32) -> * mut UnnamedPair { ferment_interfaces :: boxed (UnnamedPair (o_0 , o_1 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UnnamedPair_destroy (ffi : * mut UnnamedPair) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: ArrayOfArraysOfHashes\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct ArrayOfArraysOfHashes (* mut crate :: fermented :: generics :: Vec_Vec_crate_nested_HashID ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: ArrayOfArraysOfHashes > for ArrayOfArraysOfHashes { unsafe fn ffi_from_const (ffi : * const ArrayOfArraysOfHashes) -> crate :: nested :: ArrayOfArraysOfHashes { let ffi_ref = & * ffi ; ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) } unsafe fn ffi_to_const (obj : crate :: nested :: ArrayOfArraysOfHashes) -> * const ArrayOfArraysOfHashes { ferment_interfaces :: boxed (ArrayOfArraysOfHashes (ferment_interfaces :: FFIConversion :: ffi_to (obj))) } unsafe fn destroy (ffi : * mut ArrayOfArraysOfHashes) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ArrayOfArraysOfHashes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ArrayOfArraysOfHashes_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_Vec_crate_nested_HashID) -> * mut ArrayOfArraysOfHashes { ferment_interfaces :: boxed (ArrayOfArraysOfHashes (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ArrayOfArraysOfHashes_destroy (ffi : * mut ArrayOfArraysOfHashes) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: UsedKeyMatrix\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct UsedKeyMatrix (* mut crate :: fermented :: generics :: Vec_bool ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: UsedKeyMatrix > for UsedKeyMatrix { unsafe fn ffi_from_const (ffi : * const UsedKeyMatrix) -> crate :: nested :: UsedKeyMatrix { let ffi_ref = & * ffi ; ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) } unsafe fn ffi_to_const (obj : crate :: nested :: UsedKeyMatrix) -> * const UsedKeyMatrix { ferment_interfaces :: boxed (UsedKeyMatrix (ferment_interfaces :: FFIConversion :: ffi_to (obj))) } unsafe fn destroy (ffi : * mut UsedKeyMatrix) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for UsedKeyMatrix { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UsedKeyMatrix_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_bool) -> * mut UsedKeyMatrix { ferment_interfaces :: boxed (UsedKeyMatrix (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UsedKeyMatrix_destroy (ffi : * mut UsedKeyMatrix) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: Hash160\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Hash160 (* mut [u8 ; 20] ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: Hash160 > for Hash160 { unsafe fn ffi_from_const (ffi : * const Hash160) -> crate :: nested :: Hash160 { let ffi_ref = & * ffi ; * ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: nested :: Hash160) -> * const Hash160 { ferment_interfaces :: boxed (Hash160 (ferment_interfaces :: boxed (obj))) } unsafe fn destroy (ffi : * mut Hash160) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Hash160 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Hash160_ctor (o_0 : * mut [u8 ; 20]) -> * mut Hash160 { ferment_interfaces :: boxed (Hash160 (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Hash160_destroy (ffi : * mut Hash160) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the get_identity2"] # [doc = r" # Safety"] # [no_mangle] pub unsafe extern "C" fn ffi_get_identity2 (identifier : * mut crate :: fermented :: types :: nested :: Identifier ,) -> * mut crate :: fermented :: types :: nested :: Identity { let obj = crate :: nested :: get_identity2 (ferment_interfaces :: FFIConversion :: ffi_from (identifier) ,) ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } # [doc = "FFI-representation of the SecurityLevel"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum SecurityLevel { MASTER = 0 , CRITICAL = 1 , HIGH = 2 , MEDIUM = 3 , } impl ferment_interfaces :: FFIConversion < crate :: nested :: SecurityLevel > for SecurityLevel { unsafe fn ffi_from_const (ffi : * const SecurityLevel) -> crate :: nested :: SecurityLevel { let ffi_ref = & * ffi ; match ffi_ref { SecurityLevel :: MASTER => crate :: nested :: SecurityLevel :: MASTER , SecurityLevel :: CRITICAL => crate :: nested :: SecurityLevel :: CRITICAL , SecurityLevel :: HIGH => crate :: nested :: SecurityLevel :: HIGH , SecurityLevel :: MEDIUM => crate :: nested :: SecurityLevel :: MEDIUM , } } unsafe fn ffi_to_const (obj : crate :: nested :: SecurityLevel) -> * const SecurityLevel { ferment_interfaces :: boxed (match obj { crate :: nested :: SecurityLevel :: MASTER => SecurityLevel :: MASTER , crate :: nested :: SecurityLevel :: CRITICAL => SecurityLevel :: CRITICAL , crate :: nested :: SecurityLevel :: HIGH => SecurityLevel :: HIGH , crate :: nested :: SecurityLevel :: MEDIUM => SecurityLevel :: MEDIUM , }) } unsafe fn destroy (ffi : * mut SecurityLevel) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for SecurityLevel { fn drop (& mut self) { unsafe { match self { SecurityLevel :: MASTER => { } , SecurityLevel :: CRITICAL => { } , SecurityLevel :: HIGH => { } , SecurityLevel :: MEDIUM => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn SecurityLevel_destroy (ffi : * mut SecurityLevel) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: Revision\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Revision (u64 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: Revision > for Revision { unsafe fn ffi_from_const (ffi : * const Revision) -> crate :: nested :: Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } unsafe fn ffi_to_const (obj : crate :: nested :: Revision) -> * const Revision { ferment_interfaces :: boxed (Revision (obj)) } unsafe fn destroy (ffi : * mut Revision) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Revision { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Revision_ctor (o_0 : u64) -> * mut Revision { ferment_interfaces :: boxed (Revision (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Revision_destroy (ffi : * mut Revision) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the crate :: nested :: BinaryData\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct BinaryData (* mut crate :: fermented :: generics :: Vec_u8 ,) ; impl ferment_interfaces :: FFIConversion < crate :: nested :: BinaryData > for BinaryData { unsafe fn ffi_from_const (ffi : * const BinaryData) -> crate :: nested :: BinaryData { let ffi_ref = & * ffi ; crate :: nested :: BinaryData (ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . 0) ,) } unsafe fn ffi_to_const (obj : crate :: nested :: BinaryData) -> * const BinaryData { ferment_interfaces :: boxed (BinaryData (ferment_interfaces :: FFIConversion :: ffi_to (obj . 0) ,)) } unsafe fn destroy (ffi : * mut BinaryData) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for BinaryData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . 0) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn BinaryData_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut BinaryData { ferment_interfaces :: boxed (BinaryData (o_0 ,)) } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn BinaryData_destroy (ffi : * mut BinaryData) { ferment_interfaces :: unbox_any (ffi) ; } } } # [allow (clippy :: let_and_return , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables , unused_qualifications)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < u32 > > > > for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32) -> std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < u32 > > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < u32 > > >) -> * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , Vec < u32 > > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: chain :: common :: chain_type :: ChainType , pub values : * mut * mut crate :: fermented :: types :: nested :: HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: chain :: common :: chain_type :: ChainType , crate :: nested :: HashID > > for std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID) -> std :: collections :: BTreeMap < crate :: chain :: common :: chain_type :: ChainType , crate :: nested :: HashID > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: chain :: common :: chain_type :: ChainType , crate :: nested :: HashID >) -> * const std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: chain :: common :: chain_type :: ChainType , crate :: fermented :: types :: chain :: common :: chain_type :: ChainType > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_chain_common_chain_type_ChainType_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < u32 > > > > for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32) -> std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < u32 > > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < u32 > > >) -> * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , Vec < u32 > > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u32 > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > > > for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID) -> std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > >) -> * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > > for std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) -> std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > >) -> * const std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > , crate :: fermented :: generics :: std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 , } impl ferment_interfaces :: FFIConversion < Vec < u8 >> for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_u8) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_u8 { type Value = u8 ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_u32 { pub count : usize , pub values : * mut u32 , } impl ferment_interfaces :: FFIConversion < Vec < u32 >> for Vec_u32 { unsafe fn ffi_from_const (ffi : * const Vec_u32) -> Vec < u32 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < u32 >) -> * const Vec_u32 { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_u32 { type Value = u32 ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_crate_nested_HashID { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: types :: nested :: HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > > for std_collections_Map_keys_u32_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_crate_nested_HashID) -> std :: collections :: BTreeMap < u32 , crate :: nested :: HashID > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , crate :: nested :: HashID >) -> * const std_collections_Map_keys_u32_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > > > for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) -> std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > >) -> * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_Vec_crate_nested_HashID { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < Vec < Vec < crate :: nested :: HashID > >> for Vec_Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const Vec_Vec_crate_nested_HashID) -> Vec < Vec < crate :: nested :: HashID > > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < Vec < crate :: nested :: HashID > >) -> * const Vec_Vec_crate_nested_HashID { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_Vec_crate_nested_HashID { type Value = Vec < crate :: nested :: HashID > ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: generics :: Vec_crate_nested_HashID > (obj . into_iter ()) }) } } impl Drop for Vec_Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: generics :: Vec_u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < u32 > > > for std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_Vec_u32) -> std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < u32 > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < u32 > >) -> * const std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < Vec < u32 > , crate :: fermented :: generics :: Vec_u32 > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > > > for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) -> std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > >) -> * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { pub ok : * mut crate :: fermented :: types :: nested :: HashID , pub error : * mut crate :: fermented :: types :: nested :: ProtocolError , } impl ferment_interfaces :: FFIConversion < Result < crate :: nested :: HashID , crate :: nested :: ProtocolError > > for Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError) -> Result < crate :: nested :: HashID , crate :: nested :: ProtocolError > { let ffi_ref = & * ffi ; if ffi_ref . error . is_null () { Ok (ferment_interfaces :: FFIConversion :: ffi_from_const (ffi_ref . ok)) } else { Err (ferment_interfaces :: FFIConversion :: ffi_from_const (ffi_ref . error)) } } unsafe fn ffi_to_const (obj : Result < crate :: nested :: HashID , crate :: nested :: ProtocolError >) -> * const Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { let (ok , error) = match obj { Ok (obj) => (ferment_interfaces :: FFIConversion :: ffi_to (obj) , std :: ptr :: null_mut ()) , Err (err) => (std :: ptr :: null_mut () , ferment_interfaces :: FFIConversion :: ffi_to (err)) } ; ferment_interfaces :: boxed (Self { ok , error }) } unsafe fn destroy (ffi : * mut Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Result_ok_crate_nested_HashID_err_crate_nested_ProtocolError { fn drop (& mut self) { unsafe { if ! self . ok . is_null () { ferment_interfaces :: unbox_any (self . ok) ; } if ! self . error . is_null () { ferment_interfaces :: unbox_any (self . error) ; } } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: generics :: Vec_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < crate :: nested :: HashID > > > for std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID) -> std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < crate :: nested :: HashID > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , Vec < crate :: nested :: HashID > >) -> * const std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < Vec < crate :: nested :: HashID > , crate :: fermented :: generics :: Vec_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: KeyID , pub values : * mut * mut crate :: fermented :: types :: nested :: IdentityPublicKey , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: KeyID , crate :: nested :: IdentityPublicKey > > for std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey) -> std :: collections :: BTreeMap < crate :: nested :: KeyID , crate :: nested :: IdentityPublicKey > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: KeyID , crate :: nested :: IdentityPublicKey >) -> * const std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: KeyID , crate :: fermented :: types :: nested :: KeyID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: IdentityPublicKey , crate :: fermented :: types :: nested :: IdentityPublicKey > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_KeyID_values_crate_nested_IdentityPublicKey { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_Vec_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , Vec < u32 > > > for std_collections_Map_keys_u32_values_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Vec_u32) -> std :: collections :: BTreeMap < u32 , Vec < u32 > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Vec < u32 > >) -> * const std_collections_Map_keys_u32_values_Vec_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < Vec < u32 > , crate :: fermented :: generics :: Vec_u32 > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_nested_HashID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: nested :: HashID , } impl ferment_interfaces :: FFIConversion < Vec < crate :: nested :: HashID >> for Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const Vec_crate_nested_HashID) -> Vec < crate :: nested :: HashID > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: nested :: HashID >) -> * const Vec_crate_nested_HashID { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_nested_HashID { type Value = crate :: nested :: HashID ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: nested :: HashID > (obj . into_iter ()) }) } } impl Drop for Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , u32 > > for std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_u32) -> std :: collections :: BTreeMap < u32 , u32 > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , u32 >) -> * const std_collections_Map_keys_u32_values_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: to_simple_vec (obj . values () . cloned () . collect ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: types :: nested :: HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > > for std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) -> std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , crate :: nested :: HashID >) -> * const std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , u32 > > > for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32) -> std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , u32 > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , std :: collections :: BTreeMap < u32 , u32 > >) -> * const std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , u32 > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_std_collections_Map_keys_u32_values_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_bool { pub count : usize , pub values : * mut bool , } impl ferment_interfaces :: FFIConversion < Vec < bool >> for Vec_bool { unsafe fn ffi_from_const (ffi : * const Vec_bool) -> Vec < bool > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < bool >) -> * const Vec_bool { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_bool) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_bool { type Value = bool ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_bool { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_Vec_u32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u32 , } impl ferment_interfaces :: FFIConversion < Vec < Vec < u32 > >> for Vec_Vec_u32 { unsafe fn ffi_from_const (ffi : * const Vec_Vec_u32) -> Vec < Vec < u32 > > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < Vec < u32 > >) -> * const Vec_Vec_u32 { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_Vec_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_Vec_u32 { type Value = Vec < u32 > ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: generics :: Vec_u32 > (obj . into_iter ()) }) } } impl Drop for Vec_Vec_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_String_values_crate_nested_HashID { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: nested :: HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < String , crate :: nested :: HashID > > for std_collections_Map_keys_String_values_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_crate_nested_HashID) -> std :: collections :: BTreeMap < String , crate :: nested :: HashID > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , crate :: nested :: HashID >) -> * const std_collections_Map_keys_String_values_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < String , std :: os :: raw :: c_char > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_String_values_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_String_values_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > > > for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) -> std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > >) -> * const std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > , crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_crate_nested_HashID , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > > for std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) -> std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_simple_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Vec < crate :: nested :: HashID > >) -> * const std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: to_simple_vec (obj . keys () . cloned () . collect ()) , values : ferment_interfaces :: complex_vec_iterator :: < Vec < crate :: nested :: HashID > , crate :: fermented :: generics :: Vec_crate_nested_HashID > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_u32_values_Vec_crate_nested_HashID) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_u32_values_Vec_crate_nested_HashID { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_nested_HashID_values_u32 { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: nested :: HashID , pub values : * mut u32 , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: nested :: HashID , u32 > > for std_collections_Map_keys_crate_nested_HashID_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_nested_HashID_values_u32) -> std :: collections :: BTreeMap < crate :: nested :: HashID , u32 > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_simple_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: nested :: HashID , u32 >) -> * const std_collections_Map_keys_crate_nested_HashID_values_u32 { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: nested :: HashID , crate :: fermented :: types :: nested :: HashID > (obj . keys () . cloned ()) , values : ferment_interfaces :: to_simple_vec (obj . values () . cloned () . collect :: < Vec < _ >> ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_nested_HashID_values_u32) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_nested_HashID_values_u32 { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } }